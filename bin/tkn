#!/usr/bin/env bash
set -euo pipefail

APP_NAME="tkn"
VERSION="0.0.12"
NOTEBOOK_DIR_DEFAULT="$HOME/.taken/notebooks"
CONFIG_DIR="${TAKEN_CONFIG_DIR:-$HOME/.config/taken}"
EDITOR_FILE="$CONFIG_DIR/editor"
DEFAULT_NOTEBOOK_FILE="$CONFIG_DIR/default_notebook"
NOTEBOOK_DIR_FILE="$CONFIG_DIR/notebooks_dir"
WRAP_PREVIEW_FILE="$CONFIG_DIR/preview_wrap"
GIT_REMOTE_FILE="$CONFIG_DIR/git_remote"
ENTRY_FORMAT_FILE="$CONFIG_DIR/entry_format"
WEEK_START_FILE="$CONFIG_DIR/week_start"
NOTEBOOK_DIR="${TAKEN_DIR:-$NOTEBOOK_DIR_DEFAULT}"
DATE_FMT="%Y-%m-%d"

usage() {
  cat <<'USAGE'
Taken CLI

Usage:
  tkn [command] [args]
  taken [command] [args]

Commands:
  add [name]                Create a new notebook
  remove [name]             Remove a notebook
  search [query]            Search notebooks for a phrase
  open [name]               Open a notebook in a simple TUI
  edit [name]               Edit a notebook in your editor
  default [name]            Set the default notebook (use --clear to unset)
  sync [remote]             Sync notebooks with a git repo
  config <key> [value]      Set or show configuration values
  version                   Show version

Date queries:
  today                     Notebooks with notes from today
  yesterday                 Notebooks with notes from yesterday
  this week                 Notebooks with notes from this calendar week
  this month                Notebooks with notes from this calendar month
  last week                 Notebooks with notes from the previous calendar week
  last month                Notebooks with notes from the previous calendar month
  between <m1> <m2> [year]   Notes between months (e.g. jun aug 2024)
  on <YYYY-MM-DD>           Notebooks with notes on a date

Defaults:
  tkn                        Append clipboard to default notebook if set
  tkn <notebook>             Append clipboard to a notebook by name
  tkn --select | -s          Select a notebook interactively

Config:
  TAKEN_DIR                  Notebooks directory (default: ~/.taken/notebooks)
  TAKEN_CONFIG_DIR           Config directory (default: ~/.config/taken)
  ~/.config/taken/editor     Default editor (saved when prompted)
  ~/.config/taken/default_notebook  Default notebook name
  ~/.config/taken/notebooks_dir     Default notebooks directory
  ~/.config/taken/preview_wrap      Preview wrap setting (wrap/nowrap)
  ~/.config/taken/entry_format      Default entry format (paragraph/list)
  ~/.config/taken/week_start        Week start day (monday/sunday)
  ~/.config/taken/git_remote        Git remote for sync
USAGE
}

load_config() {
  if [[ -z "${TAKEN_DIR:-}" && -f "$NOTEBOOK_DIR_FILE" ]]; then
    local dir
    dir=$(cat "$NOTEBOOK_DIR_FILE")
    if [[ -n "$dir" ]]; then
      NOTEBOOK_DIR="$dir"
    fi
  fi
}

ensure_dir() {
  mkdir -p "$NOTEBOOK_DIR"
}

validate_name() {
  local name="$1"
  if [[ -z "$name" ]]; then
    echo "Notebook name is required." >&2
    return 1
  fi
  if [[ "$name" == *"/"* ]]; then
    echo "Notebook name cannot contain '/' characters." >&2
    return 1
  fi
}

notebook_path() {
  local name="$1"
  printf '%s/%s.md' "$NOTEBOOK_DIR" "$name"
}

print_version() {
  local script_dir
  script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
  local version_file
  version_file="$script_dir/../VERSION"
  if [[ -f "$version_file" ]]; then
    cat "$version_file"
  elif [[ -n "${VERSION:-}" ]]; then
    echo "$VERSION"
  else
    echo "unknown"
  fi
}

is_reserved_name() {
  local name="$1"
  case "$name" in
    add|remove|rm|delete|search|find|open|view|edit|default|config|sync|version|today|yesterday|this|last|between|on|help|-h|--help|-s|--select|-v|--version)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

resolve_editor() {
  local editor="${VISUAL:-${EDITOR:-}}"
  if [[ -n "$editor" ]]; then
    printf '%s' "$editor"
    return 0
  fi
  if [[ -f "$EDITOR_FILE" ]]; then
    editor=$(cat "$EDITOR_FILE")
    if [[ -n "$editor" ]]; then
      printf '%s' "$editor"
      return 0
    fi
  fi
  return 1
}

get_default_notebook() {
  if [[ -f "$DEFAULT_NOTEBOOK_FILE" ]]; then
    local name
    name=$(cat "$DEFAULT_NOTEBOOK_FILE")
    if [[ -n "$name" && -f "$(notebook_path "$name")" ]]; then
      printf '%s' "$name"
    fi
  fi
}

get_preview_wrap() {
  local wrap="wrap"
  if [[ -f "$WRAP_PREVIEW_FILE" ]]; then
    local val
    val=$(cat "$WRAP_PREVIEW_FILE")
    if [[ "$val" == "nowrap" ]]; then
      wrap="nowrap"
    fi
  fi
  printf '%s' "$wrap"
}

set_preview_wrap() {
  local mode="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$mode" > "$WRAP_PREVIEW_FILE"
}

set_default_notebook() {
  local name="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$name" > "$DEFAULT_NOTEBOOK_FILE"
}

clear_default_notebook() {
  rm -f "$DEFAULT_NOTEBOOK_FILE"
}

get_git_remote() {
  if [[ -f "$GIT_REMOTE_FILE" ]]; then
    cat "$GIT_REMOTE_FILE"
  fi
}

set_git_remote() {
  local remote="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$remote" > "$GIT_REMOTE_FILE"
}

get_editor() {
  local editor
  if editor=$(resolve_editor); then
    printf '%s' "$editor"
    return 0
  fi
  read -r -p "Editor (default: vi): " editor
  editor="${editor:-vi}"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$editor" > "$EDITOR_FILE"
  printf '%s' "$editor"
}

list_notebooks() {
  local files=()
  local f
  for f in "$NOTEBOOK_DIR"/*.md; do
    [[ -e "$f" ]] || continue
    case "$f" in
      *~ | *.swp | *.swo | *.swx | *.bak | *.tmp | *.orig | *.rej)
        continue
        ;;
    esac
    files+=("$f")
  done
  local names=()
  for f in "${files[@]}"; do
    local name
    name=$(basename "$f" .md)
    if [[ -z "${name//[[:space:]]/}" ]]; then
      continue
    fi
    names+=("$name")
  done
  printf '%s\n' "${names[@]}"
}

get_entry_format() {
  local format="paragraph"
  if [[ -f "$ENTRY_FORMAT_FILE" ]]; then
    local val
    val=$(cat "$ENTRY_FORMAT_FILE")
    if [[ "$val" == "list" ]]; then
      format="list"
    fi
  fi
  printf '%s' "$format"
}

set_entry_format() {
  local format="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$format" > "$ENTRY_FORMAT_FILE"
}

get_week_start() {
  if [[ -f "$WEEK_START_FILE" ]]; then
    local val
    val=$(cat "$WEEK_START_FILE")
    if [[ "$val" == "sunday" || "$val" == "monday" ]]; then
      printf '%s' "$val"
      return 0
    fi
  fi
  printf '%s' "monday"
}

set_week_start() {
  local start="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$start" > "$WEEK_START_FILE"
}

use_fzf() {
  if [[ "${TAKEN_NO_FZF:-}" == "1" ]]; then
    return 1
  fi
  command -v fzf >/dev/null 2>&1
}

open_notebook_at_date() {
  local name="$1"
  local date="$2"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  local heading="## $date"
  local line
  line=$(awk -v h="$heading" '$0 == h { print NR; exit }' "$file")
  if [[ -z "$line" ]]; then
    line=1
  fi

  if use_fzf; then
    local wrap_mode
    wrap_mode=$(get_preview_wrap)
    printf '%s\n' "$name | $date" | fzf --prompt="Notebook> " --height=70% --border \
      --preview "tail -n +$line \"$file\"" --preview-window=right:60%:"$wrap_mode" \
      --bind "ctrl-j:preview-down,ctrl-k:preview-up,pgdn:preview-page-down,pgup:preview-page-up,ctrl-f:preview-page-down,ctrl-b:preview-page-up,ctrl-l:toggle-preview" \
      --header "Enter/Esc to exit | Ctrl-J/K scroll | Ctrl-L toggle preview" || true
    return 0
  fi

  less "+$line" "$file"
}

date_tool_style() {
  if date -j -f "%Y-%m-%d" "1970-01-01" "+%s" >/dev/null 2>&1; then
    echo "bsd"
  else
    echo "gnu"
  fi
}

date_shift() {
  local base="$1"
  local days="$2"
  if [[ ! "$base" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    base=$(date +"%Y-%m-%d")
  fi
  local style
  style=$(date_tool_style)
  if [[ "$style" == "bsd" ]]; then
    date -j -v"${days}d" -f "%Y-%m-%d" "$base" "+%Y-%m-%d"
  else
    date -d "$base $days days" "+%Y-%m-%d"
  fi
}

date_to_epoch() {
  local d="$1"
  local style
  style=$(date_tool_style)
  if [[ "$style" == "bsd" ]]; then
    date -j -f "%Y-%m-%d" "$d" "+%s"
  else
    date -d "$d" "+%s"
  fi
}

date_day_of_week_iso() {
  local d="$1"
  local style
  style=$(date_tool_style)
  if [[ "$style" == "bsd" ]]; then
    date -j -f "%Y-%m-%d" "$d" "+%u"
  else
    date -d "$d" "+%u"
  fi
}

week_start_offset() {
  local dow="$1"
  local week_start="$2"
  case "$week_start" in
    sunday)
      echo $((dow % 7))
      ;;
    monday|*)
      echo $((dow - 1))
      ;;
  esac
}

current_week_start() {
  local today="$1"
  local week_start
  week_start=$(get_week_start)
  local dow
  dow=$(date_day_of_week_iso "$today")
  local offset
  offset=$(week_start_offset "$dow" "$week_start")
  date_shift "$today" "-$offset"
}

month_to_num() {
  local m
  m=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$m" in
    jan|january|1|01) echo "01" ;;
    feb|february|2|02) echo "02" ;;
    mar|march|3|03) echo "03" ;;
    apr|april|4|04) echo "04" ;;
    may|5|05) echo "05" ;;
    jun|june|6|06) echo "06" ;;
    jul|july|7|07) echo "07" ;;
    aug|august|8|08) echo "08" ;;
    sep|sept|september|9|09) echo "09" ;;
    oct|october|10) echo "10" ;;
    nov|november|11) echo "11" ;;
    dec|december|12) echo "12" ;;
    *) return 1 ;;
  esac
}

last_day_of_month() {
  local year="$1"
  local month="$2"
  local style
  style=$(date_tool_style)
  local next_year="$year"
  local next_month
  if [[ "$month" == "12" ]]; then
    next_month="01"
    next_year=$((year + 1))
  else
    next_month=$(printf '%02d' "$((10#$month + 1))")
  fi

  local first_next="${next_year}-${next_month}-01"
  if [[ "$style" == "bsd" ]]; then
    date -j -v-1d -f "%Y-%m-%d" "$first_next" "+%Y-%m-%d"
  else
    date -d "$first_next -1 day" "+%Y-%m-%d"
  fi
}

collect_dates() {
  awk '
    /^## [0-9]{4}-[0-9]{2}-[0-9]{2}$/ {
      file = FILENAME
      sub(/^.*\//, "", file)
      sub(/\.md$/, "", file)
      date = substr($0, 4)
      print file "|" date
    }
  ' "$NOTEBOOK_DIR"/*.md 2>/dev/null
}

print_date_matches() {
  local start="$1"
  local end="$2"
  if [[ -z "$(list_notebooks)" ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  local start_epoch
  local end_epoch
  start_epoch=$(date_to_epoch "$start")
  end_epoch=$(date_to_epoch "$end")
  local matched=0

  local output=()
  local line
  while IFS='|' read -r nb date; do
    [[ -z "$nb" || -z "$date" ]] && continue
    local date_epoch
    date_epoch=$(date_to_epoch "$date")
    if ((date_epoch >= start_epoch && date_epoch <= end_epoch)); then
      output+=("$nb | $date")
      matched=1
    fi
  done < <(collect_dates)

  if [[ "$matched" -eq 0 ]]; then
    echo "No notes found for range." >&2
    return 0
  fi

  if use_fzf; then
    local selected
    selected=$(printf '%s\n' "${output[@]}" | fzf --prompt="Dates> " --height=60% --border) || return 0
    if [[ -n "$selected" ]]; then
      local nb
      local date
      nb=${selected%% | *}
      date=${selected##* | }
      open_notebook_at_date "$nb" "$date"
    fi
  else
    echo "Select a date entry:" >&2
    local i
    for i in "${!output[@]}"; do
      printf '%s) %s\n' "$((i + 1))" "${output[$i]}" >&2
    done
    local choice
    while true; do
      read -r -p "Enter number: " choice
      if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#output[@]})); then
        local selected="${output[$((choice - 1))]}"
        local nb
        local date
        nb=${selected%% | *}
        date=${selected##* | }
        open_notebook_at_date "$nb" "$date"
        break
      fi
      echo "Invalid selection." >&2
    done
  fi
}

select_notebook() {
  local default
  default=$(get_default_notebook)

  if use_fzf; then
    local ordered=()
    local n
    while IFS= read -r n; do
      [[ -z "$n" ]] && continue
      if [[ -n "$default" && "$n" == "$default" ]]; then
        if [[ ${#ordered[@]} -eq 0 ]]; then
          ordered=("$n")
        else
          ordered=("$n" "${ordered[@]}")
        fi
      else
        ordered+=("$n")
      fi
    done < <(list_notebooks)

    if [[ ${#ordered[@]} -eq 0 ]]; then
      echo "No notebooks found. Use 'tkn add' to create one." >&2
      return 1
    fi

    local fzf_header=""
    if [[ -n "$default" ]]; then
      fzf_header="Default: $default"
    fi
    local chosen
    chosen=$(printf '%s\n' "${ordered[@]}" | fzf --prompt="Notebook> " --height=40% --border --no-sort --header "$fzf_header") || return 1
    if [[ -z "$chosen" ]]; then
      return 1
    fi
    printf '%s' "$chosen"
    return 0
  fi

  local notebooks=()
  local n
  while IFS= read -r n; do
    [[ -n "$n" ]] && notebooks+=("$n")
  done < <(list_notebooks)

  if [[ ${#notebooks[@]} -eq 0 ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  echo "Select a notebook:" >&2
  local i
  for i in "${!notebooks[@]}"; do
    local label="${notebooks[$i]}"
    if [[ -n "$default" && "$label" == "$default" ]]; then
      label="$label (default)"
    fi
    printf '%s) %s\n' "$((i + 1))" "$label" >&2
  done

  local default_index=""
  if [[ -n "$default" ]]; then
    for i in "${!notebooks[@]}"; do
      if [[ "${notebooks[$i]}" == "$default" ]]; then
        default_index=$((i + 1))
        break
      fi
    done
  fi

  local choice
  while true; do
    if [[ -n "$default_index" ]]; then
      read -r -p "Enter number (default ${default_index}): " choice
      if [[ -z "$choice" ]]; then
        printf '%s' "$default"
        return 0
      fi
    else
      read -r -p "Enter number: " choice
    fi
    if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#notebooks[@]})); then
      printf '%s' "${notebooks[$((choice - 1))]}"
      return 0
    fi
    echo "Invalid selection." >&2
  done
}

get_clipboard() {
  if command -v pbpaste >/dev/null 2>&1; then
    pbpaste
  elif command -v wl-paste >/dev/null 2>&1; then
    wl-paste
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -o
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --output
  else
    echo "No clipboard tool found (pbpaste, wl-paste, xclip, xsel)." >&2
    return 1
  fi
}

linkify_text() {
  local line="$1"
  printf '%s' "$line" | perl -pe '
    my @link_tokens;
    my $li = 0;
    s/(\[[^\[\]]+\]\([^)]+\))/push @link_tokens, $1; "__TAKEN_LINK_" . $li++ . "__"/ge;

    my @code_tokens;
    my $ci = 0;
    s/(`[^`]+`)/push @code_tokens, $1; "__TAKEN_CODE_" . $ci++ . "__"/ge;

    s|(https?://\S+)|[$1]($1)|g;
    s{(^|\s)(www\.\S+)}{$1 . "[$2](https://$2)"}ge;

    s/__TAKEN_LINK_(\d+)__/ $link_tokens[$1] /ge;
    s/__TAKEN_CODE_(\d+)__/ $code_tokens[$1] /ge;
  '
}

format_entry() {
  local text="$1"
  text="${text//$'\r'/}"

  local lines=()
  local line
  while IFS= read -r line; do
    lines+=("$line")
  done <<<"$text"

  if [[ ${#lines[@]} -eq 0 ]]; then
    printf '%s' "- "
    return
  fi

  local code_fence_re='^[[:space:]]*```'
  local format
  format=$(get_entry_format)

  local in_code_block=0
  if [[ "${lines[0]}" =~ $code_fence_re ]]; then
    in_code_block=1
  fi

  local out_lines=()
  local i
  for ((i = 0; i < ${#lines[@]}; i++)); do
    if [[ "${lines[$i]}" =~ $code_fence_re ]]; then
      if [[ "$in_code_block" == "1" ]]; then
        in_code_block=0
      else
        in_code_block=1
      fi
    fi

    local next
    if [[ "$in_code_block" == "1" ]] || [[ "${lines[$i]}" =~ ^[[:space:]][[:space:]][[:space:]][[:space:]] ]] || [[ "${lines[$i]}" =~ ^[[:space:]]*\t ]]; then
      next="${lines[$i]}"
    else
      next="$(linkify_text "${lines[$i]}")"
    fi
    out_lines+=("$next")
  done

  if [[ "$format" == "list" ]]; then
    printf '%s' "- ${out_lines[0]}"
    for ((i = 1; i < ${#out_lines[@]}; i++)); do
      printf '\n  %s' "${out_lines[$i]}"
    done
  else
    printf '%s' "${out_lines[0]}"
    for ((i = 1; i < ${#out_lines[@]}; i++)); do
      printf '\n%s' "${out_lines[$i]}"
    done
  fi
}

append_to_notebook() {
  local file="$1"
  local entry="$2"
  local today
  today=$(date +"$DATE_FMT")
  local heading="## $today"
  local format
  format=$(get_entry_format)
  local entry_existing="$entry"
  if [[ "$format" == "paragraph" ]]; then
    entry_existing=$'\n'"$entry"
  fi

  if [[ ! -f "$file" ]]; then
    printf '%s\n%s\n' "$heading" "$entry_existing" > "$file"
    return
  fi

  if ! grep -Fxq "$heading" "$file"; then
    {
      [[ -s "$file" ]] && printf '\n'
      printf '%s\n%s\n' "$heading" "$entry_existing"
    } >> "$file"
    return
  fi

  local tmp
  local entry_tmp
  tmp="${file}.tmp.$$"
  entry_tmp="${file}.entry.$$"
  printf '%s\n' "$entry_existing" > "$entry_tmp"
  if command -v python3 >/dev/null 2>&1 || command -v python >/dev/null 2>&1; then
    local py
    if command -v python3 >/dev/null 2>&1; then
      py="python3"
    else
      py="python"
    fi
    "$py" - "$file" "$entry_tmp" "$heading" <<'PY'
import sys

path, entry_path, heading = sys.argv[1:4]
with open(path, "r", encoding="utf-8") as f:
    lines = f.read().splitlines()
with open(entry_path, "r", encoding="utf-8") as f:
    entry_lines = f.read().splitlines()

out = []
in_section = False
inserted = False
for line in lines:
    if line == heading:
        out.append(line)
        in_section = True
        continue
    if in_section and line.startswith("## "):
        out.extend(entry_lines)
        out.append(line)
        in_section = False
        inserted = True
        continue
    out.append(line)

if in_section:
    out.extend(entry_lines)
    inserted = True

with open(path, "w", encoding="utf-8") as f:
    f.write("\n".join(out) + "\n")
PY
    rm -f "$entry_tmp"
  else
    awk -v heading="$heading" -v entry_file="$entry_tmp" '
      function print_entry() {
        while ((getline line < entry_file) > 0) {
          print line
        }
        close(entry_file)
      }
      $0 == heading { print; in_section = 1; next }
      in_section && $0 ~ /^## / { print_entry(); in_section = 0 }
      { print }
      END { if (in_section) print_entry() }
    ' "$file" > "$tmp"
    rm -f "$entry_tmp"
    mv "$tmp" "$file"
  fi
}

cmd_add() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    read -r -p "New notebook name: " name
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ -f "$file" ]]; then
    echo "Notebook already exists: $name" >&2
    return 1
  fi
  printf '# %s\n' "$name" > "$file"
  echo "Created notebook: $name"
}

cmd_remove() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  read -r -p "Remove '$name'? [y/N] " confirm
  case "$confirm" in
    y|Y|yes|YES)
      rm "$file"
      echo "Removed notebook: $name"
      ;;
    *)
      echo "Cancelled."
      ;;
  esac
}

cmd_append() {
  ensure_dir
  local name="${1:-}"
  local force_select="${2:-}"
  if [[ -z "$name" || -n "$force_select" ]]; then
    if [[ -z "$force_select" ]]; then
      local default
      default=$(get_default_notebook)
      if [[ -n "$default" ]]; then
        name="$default"
      fi
    fi
    if [[ -z "$name" ]]; then
      name=$(select_notebook) || return 1
    fi
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi

  local clip
  clip=$(get_clipboard)
  if [[ -z "${clip//[$' \t\r\n']/}" ]]; then
    echo "Clipboard is empty." >&2
    return 1
  fi

  local entry
  entry=$(format_entry "$clip")
  append_to_notebook "$file" "$entry"
  echo "Appended to $name"
}

cmd_search() {
  ensure_dir
  local query="${1:-}"
  if [[ -z "$query" ]]; then
    read -r -p "Search query: " query
  fi
  if [[ -z "$query" ]]; then
    echo "Search query is required." >&2
    return 1
  fi

  if [[ -z "$(list_notebooks)" ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  local pattern="$query"
  local search_cmd=(awk -v pat="$pattern" '
    FNR == 1 { date = "" }
    /^## / { date = substr($0, 4) }
    tolower($0) ~ tolower(pat) {
      file = FILENAME
      sub(/^.*\//, "", file)
      sub(/\.md$/, "", file)
      line = FNR
      content = $0
      if (date == "") {
        date = "UNKNOWN"
      }
      printf "%s:%s | %s | %s\n", file, line, date, content
    }
  ' "$NOTEBOOK_DIR"/*.md)

  if use_fzf; then
    "${search_cmd[@]}" | fzf --prompt="Results> " --height=60% --border || true
  else
    "${search_cmd[@]}" || true
  fi
}

cmd_open() {
  ensure_dir
  local name="${1:-}"
  if use_fzf; then
    local wrap_mode
    wrap_mode=$(get_preview_wrap)
    local fzf_cmd=(
      fzf
      --prompt="Notebook> "
      --height=70%
      --border
      --preview "cat \"$NOTEBOOK_DIR\"/{}.md"
      --preview-window=right:60%:${wrap_mode}
      --bind "ctrl-j:preview-down,ctrl-k:preview-up,pgdn:preview-page-down,pgup:preview-page-up,ctrl-f:preview-page-down,ctrl-b:preview-page-up,ctrl-l:toggle-preview"
      --header "Enter/Esc to exit | Ctrl-J/K scroll | Ctrl-L toggle preview"
    )

    if [[ -n "$name" ]]; then
      validate_name "$name"
      local file
      file=$(notebook_path "$name")
      if [[ ! -f "$file" ]]; then
        echo "Notebook not found: $name" >&2
        return 1
      fi
      printf '%s\n' "$name" | "${fzf_cmd[@]}" || true
      return 0
    fi

    list_notebooks | "${fzf_cmd[@]}" || true
    return 0
  fi

  if [[ -n "$name" ]]; then
    validate_name "$name"
    local file
    file=$(notebook_path "$name")
    if [[ ! -f "$file" ]]; then
      echo "Notebook not found: $name" >&2
      return 1
    fi
    less "$file"
    return 0
  fi

  name=$(select_notebook) || return 1
  less "$(notebook_path "$name")"
}

cmd_default() {
  ensure_dir
  local name="${1:-}"
  if [[ "$name" == "--clear" || "$name" == "clear" ]]; then
    clear_default_notebook
    echo "Default notebook cleared."
    return 0
  fi
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  set_default_notebook "$name"
  echo "Default notebook set to: $name"
}

cmd_config() {
  local key="${1:-}"
  local value="${2:-}"
  case "$key" in
    dir)
      if [[ -z "$value" ]]; then
        echo "$NOTEBOOK_DIR"
        return 0
      fi
      mkdir -p "$CONFIG_DIR"
      printf '%s' "$value" > "$NOTEBOOK_DIR_FILE"
      NOTEBOOK_DIR="$value"
      mkdir -p "$NOTEBOOK_DIR"
      echo "Notebooks directory set to: $NOTEBOOK_DIR"
      ;;
    editor)
      if [[ -z "$value" ]]; then
        if resolve_editor >/dev/null 2>&1; then
          resolve_editor
        else
          echo "Editor is not set."
        fi
        return 0
      fi
      mkdir -p "$CONFIG_DIR"
      printf '%s' "$value" > "$EDITOR_FILE"
      echo "Editor set to: $value"
      ;;
    wrap)
      if [[ -z "$value" ]]; then
        get_preview_wrap
        return 0
      fi
      case "$value" in
        wrap|nowrap)
          set_preview_wrap "$value"
          echo "Preview wrap set to: $value"
          ;;
        *)
          echo "Value must be 'wrap' or 'nowrap'." >&2
          return 1
          ;;
      esac
      ;;
    entry)
      if [[ -z "$value" ]]; then
        get_entry_format
        return 0
      fi
      case "$value" in
        paragraph|list)
          set_entry_format "$value"
          echo "Entry format set to: $value"
          ;;
        *)
          echo "Value must be 'paragraph' or 'list'." >&2
          return 1
          ;;
      esac
      ;;
    week)
      if [[ -z "$value" ]]; then
        get_week_start
        return 0
      fi
      case "$value" in
        monday|sunday)
          set_week_start "$value"
          echo "Week start set to: $value"
          ;;
        *)
          echo "Value must be 'monday' or 'sunday'." >&2
          return 1
          ;;
      esac
      ;;
    reset)
      rm -f "$EDITOR_FILE" "$NOTEBOOK_DIR_FILE" "$GIT_REMOTE_FILE" "$WRAP_PREVIEW_FILE" "$ENTRY_FORMAT_FILE" "$WEEK_START_FILE"
      NOTEBOOK_DIR="${TAKEN_DIR:-$NOTEBOOK_DIR_DEFAULT}"
      echo "Config reset (dir/editor/git/wrap/entry/week)."
      ;;
    ""|help|-h|--help)
      echo "Usage: tkn config <dir|editor|wrap|entry|week|reset> [value]" >&2
      return 1
      ;;
    *)
      echo "Unknown config key: $key" >&2
      return 1
      ;;
  esac
}

ensure_git_repo() {
  if [[ ! -d "$NOTEBOOK_DIR/.git" ]]; then
    git -C "$NOTEBOOK_DIR" init >/dev/null
  fi
}

cmd_sync() {
  ensure_dir
  local remote="${1:-}"
  if [[ -n "$remote" ]]; then
    set_git_remote "$remote"
    echo "Git remote set to: $remote"
    echo "Make sure git credentials are configured for this remote."
  else
    remote=$(get_git_remote)
  fi
  if [[ -z "$remote" ]]; then
    echo "No git remote configured. Run: tkn sync <remote-url>" >&2
    return 1
  fi

  if ! command -v git >/dev/null 2>&1; then
    echo "git is required for sync." >&2
    return 1
  fi

  ensure_git_repo

  if ! git -C "$NOTEBOOK_DIR" remote get-url origin >/dev/null 2>&1; then
    git -C "$NOTEBOOK_DIR" remote add origin "$remote"
  else
    git -C "$NOTEBOOK_DIR" remote set-url origin "$remote"
  fi

  local has_remote_refs=0
  if git ls-remote --exit-code --heads "$remote" >/dev/null 2>&1; then
    has_remote_refs=1
  fi

  if [[ "$has_remote_refs" -eq 1 ]]; then
    git -C "$NOTEBOOK_DIR" pull --rebase --autostash origin >/dev/null
  fi

  git -C "$NOTEBOOK_DIR" add -A
  if ! git -C "$NOTEBOOK_DIR" diff --cached --quiet; then
    git -C "$NOTEBOOK_DIR" commit -m "Update notebooks" >/dev/null
  fi

  if ! git -C "$NOTEBOOK_DIR" rev-parse --verify HEAD >/dev/null 2>&1; then
    echo "Nothing to sync." >&2
    return 0
  fi

  local branch
  branch=$(git -C "$NOTEBOOK_DIR" rev-parse --abbrev-ref HEAD)
  if [[ "$branch" == "HEAD" ]]; then
    branch="main"
    git -C "$NOTEBOOK_DIR" checkout -b "$branch" >/dev/null 2>&1 || true
  fi

  git -C "$NOTEBOOK_DIR" push -u origin "$branch" >/dev/null
  echo "Sync complete."
}

cmd_edit() {
  ensure_dir
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi

  local editor
  editor=$(get_editor)
  "$editor" "$file"
}

cmd_today() {
  local today
  today=$(date +"$DATE_FMT")
  print_date_matches "$today" "$today"
}

cmd_yesterday() {
  local today
  today=$(date +"$DATE_FMT")
  local yday
  yday=$(date_shift "$today" -1)
  print_date_matches "$yday" "$yday"
}

cmd_last() {
  local span="${1:-}"
  if [[ -z "$span" ]]; then
    echo "Usage: tkn last <week|month>" >&2
    return 1
  fi
  local today
  today=$(date +"$DATE_FMT")
  local start
  local end
  case "$span" in
    week)
      local this_start
      this_start=$(current_week_start "$today")
      start=$(date_shift "$this_start" -7)
      end=$(date_shift "$this_start" -1)
      ;;
    month)
      local year
      local month
      year=$(date +"%Y")
      month=$(date +"%m")
      if [[ "$month" == "01" ]]; then
        year=$((10#$year - 1))
        month="12"
      else
        month=$(printf '%02d' "$((10#$month - 1))")
      fi
      start="${year}-${month}-01"
      end=$(last_day_of_month "$year" "$month")
      ;;
    *)
      echo "Unknown range: $span" >&2
      return 1
      ;;
  esac
  print_date_matches "$start" "$end"
}

cmd_this() {
  local span="${1:-}"
  if [[ -z "$span" ]]; then
    echo "Usage: tkn this <week|month>" >&2
    return 1
  fi
  local today
  today=$(date +"$DATE_FMT")
  local start
  local end
  case "$span" in
    week)
      start=$(current_week_start "$today")
      end="$today"
      ;;
    month)
      local year
      local month
      year=$(date +"%Y")
      month=$(date +"%m")
      start="${year}-${month}-01"
      end=$(last_day_of_month "$year" "$month")
      ;;
    *)
      echo "Unknown range: $span" >&2
      return 1
      ;;
  esac
  print_date_matches "$start" "$end"
}

cmd_between() {
  local m1="${1:-}"
  local m2="${2:-}"
  local year="${3:-}"
  if [[ -z "$m1" || -z "$m2" ]]; then
    echo "Usage: tkn between <m1> <m2> [year]" >&2
    return 1
  fi
  if [[ -z "$year" ]]; then
    year=$(date +"%Y")
  fi
  local m1_num
  local m2_num
  m1_num=$(month_to_num "$m1") || { echo "Unknown month: $m1" >&2; return 1; }
  m2_num=$(month_to_num "$m2") || { echo "Unknown month: $m2" >&2; return 1; }
  if ((10#$m2_num < 10#$m1_num)); then
    echo "End month must be after start month." >&2
    return 1
  fi

  local start="${year}-${m1_num}-01"
  local end
  end=$(last_day_of_month "$year" "$m2_num")
  print_date_matches "$start" "$end"
}

cmd_on() {
  local d="${1:-}"
  if [[ -z "$d" ]]; then
    echo "Usage: tkn on <YYYY-MM-DD>" >&2
    return 1
  fi
  print_date_matches "$d" "$d"
}

main() {
  load_config
  ensure_dir
  local cmd="${1:-}"
  local next="${2:-}"
  case "$cmd" in
    "" )
      cmd_append
      ;;
    -s|--select)
      cmd_append "" "select"
      ;;
    -*)
      echo "Unknown option: $cmd" >&2
      usage >&2
      return 1
      ;;
    add)
      shift
      cmd_add "${1:-}"
      ;;
    remove|rm|delete)
      shift
      cmd_remove "${1:-}"
      ;;
    search|find)
      shift
      cmd_search "${1:-}"
      ;;
    open|view)
      shift
      cmd_open "${1:-}"
      ;;
    default)
      shift
      cmd_default "${1:-}"
      ;;
    config)
      shift
      cmd_config "${1:-}" "${2:-}"
      ;;
    sync)
      shift
      cmd_sync "${1:-}"
      ;;
    edit)
      shift
      cmd_edit "${1:-}"
      ;;
    today)
      cmd_today
      ;;
    yesterday)
      cmd_yesterday
      ;;
    this)
      shift
      cmd_this "${1:-}"
      ;;
    last)
      shift
      cmd_last "${1:-}"
      ;;
    between)
      shift
      cmd_between "${1:-}" "${2:-}" "${3:-}"
      ;;
    on)
      shift
      cmd_on "${1:-}"
      ;;
    help|-h|--help)
      usage
      ;;
    version|-v|--version)
      print_version
      ;;
    *)
      if is_reserved_name "$cmd"; then
        echo "Unknown command: $cmd" >&2
        usage >&2
        return 1
      fi
      cmd_append "$cmd"
      ;;
  esac
}

main "$@"
