#!/usr/bin/env bash
set -euo pipefail

APP_NAME="tkn"
NOTEBOOK_DIR_DEFAULT="$HOME/.taken/notebooks"
CONFIG_DIR="${TAKEN_CONFIG_DIR:-$HOME/.config/taken}"
EDITOR_FILE="$CONFIG_DIR/editor"
DEFAULT_NOTEBOOK_FILE="$CONFIG_DIR/default_notebook"
NOTEBOOK_DIR_FILE="$CONFIG_DIR/notebooks_dir"
WRAP_PREVIEW_FILE="$CONFIG_DIR/preview_wrap"
GIT_REMOTE_FILE="$CONFIG_DIR/git_remote"
NOTEBOOK_DIR="${TAKEN_DIR:-$NOTEBOOK_DIR_DEFAULT}"
DATE_FMT="%Y-%m-%d"

usage() {
  cat <<'USAGE'
Taken CLI

Usage:
  tkn [command] [args]
  taken [command] [args]

Commands:
  add [name]                Create a new notebook
  remove [name]             Remove a notebook
  search [query]            Search notebooks for a phrase
  open [name]               Open a notebook in a simple TUI
  edit [name]               Edit a notebook in your editor
  default [name]            Set the default notebook (use --clear to unset)
  sync [remote]             Sync notebooks with a git repo
  config <key> [value]      Set or show configuration values

Date queries:
  today                     Notebooks with notes from today
  yesterday                 Notebooks with notes from yesterday
  last week                 Notebooks with notes from the last 7 days
  last month                Notebooks with notes from the last 30 days
  between <m1> <m2> [year]   Notes between months (e.g. jun aug 2024)
  on <YYYY-MM-DD>           Notebooks with notes on a date

Defaults:
  tkn                        Append clipboard to default notebook if set
  tkn <notebook>             Append clipboard to a notebook by name
  tkn --select | -s          Select a notebook interactively

Config:
  TAKEN_DIR                  Notebooks directory (default: ~/.taken/notebooks)
  TAKEN_CONFIG_DIR           Config directory (default: ~/.config/taken)
  ~/.config/taken/editor     Default editor (saved when prompted)
  ~/.config/taken/default_notebook  Default notebook name
  ~/.config/taken/notebooks_dir     Default notebooks directory
  ~/.config/taken/preview_wrap      Preview wrap setting (wrap/nowrap)
  ~/.config/taken/git_remote        Git remote for sync
USAGE
}

load_config() {
  if [[ -z "${TAKEN_DIR:-}" && -f "$NOTEBOOK_DIR_FILE" ]]; then
    local dir
    dir=$(cat "$NOTEBOOK_DIR_FILE")
    if [[ -n "$dir" ]]; then
      NOTEBOOK_DIR="$dir"
    fi
  fi
}

ensure_dir() {
  mkdir -p "$NOTEBOOK_DIR"
}

validate_name() {
  local name="$1"
  if [[ -z "$name" ]]; then
    echo "Notebook name is required." >&2
    return 1
  fi
  if [[ "$name" == *"/"* ]]; then
    echo "Notebook name cannot contain '/' characters." >&2
    return 1
  fi
}

notebook_path() {
  local name="$1"
  printf '%s/%s.md' "$NOTEBOOK_DIR" "$name"
}

is_reserved_name() {
  local name="$1"
  case "$name" in
    add|remove|rm|delete|search|find|open|view|edit|default|config|sync|today|yesterday|last|between|on|help|-h|--help|-s|--select)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

resolve_editor() {
  local editor="${VISUAL:-${EDITOR:-}}"
  if [[ -n "$editor" ]]; then
    printf '%s' "$editor"
    return 0
  fi
  if [[ -f "$EDITOR_FILE" ]]; then
    editor=$(cat "$EDITOR_FILE")
    if [[ -n "$editor" ]]; then
      printf '%s' "$editor"
      return 0
    fi
  fi
  return 1
}

get_default_notebook() {
  if [[ -f "$DEFAULT_NOTEBOOK_FILE" ]]; then
    local name
    name=$(cat "$DEFAULT_NOTEBOOK_FILE")
    if [[ -n "$name" && -f "$(notebook_path "$name")" ]]; then
      printf '%s' "$name"
    fi
  fi
}

get_preview_wrap() {
  local wrap="wrap"
  if [[ -f "$WRAP_PREVIEW_FILE" ]]; then
    local val
    val=$(cat "$WRAP_PREVIEW_FILE")
    if [[ "$val" == "nowrap" ]]; then
      wrap="nowrap"
    fi
  fi
  printf '%s' "$wrap"
}

set_preview_wrap() {
  local mode="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$mode" > "$WRAP_PREVIEW_FILE"
}

set_default_notebook() {
  local name="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$name" > "$DEFAULT_NOTEBOOK_FILE"
}

clear_default_notebook() {
  rm -f "$DEFAULT_NOTEBOOK_FILE"
}

get_git_remote() {
  if [[ -f "$GIT_REMOTE_FILE" ]]; then
    cat "$GIT_REMOTE_FILE"
  fi
}

set_git_remote() {
  local remote="$1"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$remote" > "$GIT_REMOTE_FILE"
}

get_editor() {
  local editor
  if editor=$(resolve_editor); then
    printf '%s' "$editor"
    return 0
  fi
  read -r -p "Editor (default: vi): " editor
  editor="${editor:-vi}"
  mkdir -p "$CONFIG_DIR"
  printf '%s' "$editor" > "$EDITOR_FILE"
  printf '%s' "$editor"
}

list_notebooks() {
  local files=()
  local f
  for f in "$NOTEBOOK_DIR"/*.md; do
    [[ -e "$f" ]] || continue
    files+=("$f")
  done
  local names=()
  for f in "${files[@]}"; do
    names+=("$(basename "$f" .md)")
  done
  printf '%s\n' "${names[@]}"
}

open_notebook_at_date() {
  local name="$1"
  local date="$2"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  local heading="## $date"
  local line
  line=$(awk -v h="$heading" '$0 == h { print NR; exit }' "$file")
  if [[ -z "$line" ]]; then
    line=1
  fi

  if command -v fzf >/dev/null 2>&1; then
    local wrap_mode
    wrap_mode=$(get_preview_wrap)
    printf '%s\n' "$name | $date" | fzf --prompt="Notebook> " --height=70% --border \
      --preview "tail -n +$line \"$file\"" --preview-window=right:60%:"$wrap_mode" \
      --bind "ctrl-j:preview-down,ctrl-k:preview-up,pgdn:preview-page-down,pgup:preview-page-up,ctrl-f:preview-page-down,ctrl-b:preview-page-up,ctrl-l:toggle-preview" \
      --header "Enter/Esc to exit | Ctrl-J/K scroll | Ctrl-L toggle preview" || true
    return 0
  fi

  less "+$line" "$file"
}

date_tool_style() {
  if date -j -f "%Y-%m-%d" "1970-01-01" "+%s" >/dev/null 2>&1; then
    echo "bsd"
  else
    echo "gnu"
  fi
}

date_shift() {
  local base="$1"
  local days="$2"
  local style
  style=$(date_tool_style)
  if [[ "$style" == "bsd" ]]; then
    date -j -f "%Y-%m-%d" "$base" -v"${days}d" "+%Y-%m-%d"
  else
    date -d "$base $days days" "+%Y-%m-%d"
  fi
}

date_to_epoch() {
  local d="$1"
  local style
  style=$(date_tool_style)
  if [[ "$style" == "bsd" ]]; then
    date -j -f "%Y-%m-%d" "$d" "+%s"
  else
    date -d "$d" "+%s"
  fi
}

month_to_num() {
  local m
  m=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
  case "$m" in
    jan|january|1|01) echo "01" ;;
    feb|february|2|02) echo "02" ;;
    mar|march|3|03) echo "03" ;;
    apr|april|4|04) echo "04" ;;
    may|5|05) echo "05" ;;
    jun|june|6|06) echo "06" ;;
    jul|july|7|07) echo "07" ;;
    aug|august|8|08) echo "08" ;;
    sep|sept|september|9|09) echo "09" ;;
    oct|october|10) echo "10" ;;
    nov|november|11) echo "11" ;;
    dec|december|12) echo "12" ;;
    *) return 1 ;;
  esac
}

last_day_of_month() {
  local year="$1"
  local month="$2"
  local style
  style=$(date_tool_style)
  local next_year="$year"
  local next_month
  if [[ "$month" == "12" ]]; then
    next_month="01"
    next_year=$((year + 1))
  else
    next_month=$(printf '%02d' "$((10#$month + 1))")
  fi

  local first_next="${next_year}-${next_month}-01"
  if [[ "$style" == "bsd" ]]; then
    date -j -f "%Y-%m-%d" "$first_next" -v-1d "+%Y-%m-%d"
  else
    date -d "$first_next -1 day" "+%Y-%m-%d"
  fi
}

collect_dates() {
  awk '
    /^## [0-9]{4}-[0-9]{2}-[0-9]{2}$/ {
      file = FILENAME
      sub(/^.*\//, "", file)
      sub(/\.md$/, "", file)
      date = substr($0, 4)
      print file "|" date
    }
  ' "$NOTEBOOK_DIR"/*.md 2>/dev/null
}

print_date_matches() {
  local start="$1"
  local end="$2"
  if [[ -z "$(list_notebooks)" ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  local start_epoch
  local end_epoch
  start_epoch=$(date_to_epoch "$start")
  end_epoch=$(date_to_epoch "$end")
  local matched=0

  local output=()
  local line
  while IFS='|' read -r nb date; do
    [[ -z "$nb" || -z "$date" ]] && continue
    local date_epoch
    date_epoch=$(date_to_epoch "$date")
    if ((date_epoch >= start_epoch && date_epoch <= end_epoch)); then
      output+=("$nb | $date")
      matched=1
    fi
  done < <(collect_dates)

  if [[ "$matched" -eq 0 ]]; then
    echo "No notes found for range." >&2
    return 0
  fi

  if command -v fzf >/dev/null 2>&1; then
    local selected
    selected=$(printf '%s\n' "${output[@]}" | fzf --prompt="Dates> " --height=60% --border) || return 0
    if [[ -n "$selected" ]]; then
      local nb
      local date
      nb=${selected%% | *}
      date=${selected##* | }
      open_notebook_at_date "$nb" "$date"
    fi
  else
    echo "Select a date entry:" >&2
    local i
    for i in "${!output[@]}"; do
      printf '%s) %s\n' "$((i + 1))" "${output[$i]}" >&2
    done
    local choice
    while true; do
      read -r -p "Enter number: " choice
      if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#output[@]})); then
        local selected="${output[$((choice - 1))]}"
        local nb
        local date
        nb=${selected%% | *}
        date=${selected##* | }
        open_notebook_at_date "$nb" "$date"
        break
      fi
      echo "Invalid selection." >&2
    done
  fi
}

select_notebook() {
  local default
  default=$(get_default_notebook)

  if command -v fzf >/dev/null 2>&1; then
    local ordered=()
    local n
    while IFS= read -r n; do
      [[ -z "$n" ]] && continue
      if [[ -n "$default" && "$n" == "$default" ]]; then
        ordered=("$n" "${ordered[@]}")
      else
        ordered+=("$n")
      fi
    done < <(list_notebooks)

    if [[ ${#ordered[@]} -eq 0 ]]; then
      echo "No notebooks found. Use 'tkn add' to create one." >&2
      return 1
    fi

    local fzf_header=""
    if [[ -n "$default" ]]; then
      fzf_header="Default: $default"
    fi
    local chosen
    chosen=$(printf '%s\n' "${ordered[@]}" | fzf --prompt="Notebook> " --height=40% --border --no-sort --header "$fzf_header") || return 1
    if [[ -z "$chosen" ]]; then
      return 1
    fi
    printf '%s' "$chosen"
    return 0
  fi

  local notebooks=()
  local n
  while IFS= read -r n; do
    [[ -n "$n" ]] && notebooks+=("$n")
  done < <(list_notebooks)

  if [[ ${#notebooks[@]} -eq 0 ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  echo "Select a notebook:" >&2
  local i
  for i in "${!notebooks[@]}"; do
    local label="${notebooks[$i]}"
    if [[ -n "$default" && "$label" == "$default" ]]; then
      label="$label (default)"
    fi
    printf '%s) %s\n' "$((i + 1))" "$label" >&2
  done

  local default_index=""
  if [[ -n "$default" ]]; then
    for i in "${!notebooks[@]}"; do
      if [[ "${notebooks[$i]}" == "$default" ]]; then
        default_index=$((i + 1))
        break
      fi
    done
  fi

  local choice
  while true; do
    if [[ -n "$default_index" ]]; then
      read -r -p "Enter number (default ${default_index}): " choice
      if [[ -z "$choice" ]]; then
        printf '%s' "$default"
        return 0
      fi
    else
      read -r -p "Enter number: " choice
    fi
    if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#notebooks[@]})); then
      printf '%s' "${notebooks[$((choice - 1))]}"
      return 0
    fi
    echo "Invalid selection." >&2
  done
}

get_clipboard() {
  if command -v pbpaste >/dev/null 2>&1; then
    pbpaste
  elif command -v wl-paste >/dev/null 2>&1; then
    wl-paste
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -o
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --output
  else
    echo "No clipboard tool found (pbpaste, wl-paste, xclip, xsel)." >&2
    return 1
  fi
}

format_entry() {
  local text="$1"
  text="${text//$'\r'/}"

  local lines=()
  local line
  while IFS= read -r line; do
    lines+=("$line")
  done <<<"$text"

  if [[ ${#lines[@]} -eq 0 ]]; then
    printf '%s' "- "
    return
  fi

  printf '%s' "- ${lines[0]}"
  local i
  for ((i = 1; i < ${#lines[@]}; i++)); do
    printf '\n  %s' "${lines[$i]}"
  done
}

append_to_notebook() {
  local file="$1"
  local entry="$2"
  local today
  today=$(date +"$DATE_FMT")
  local heading="## $today"

  if [[ ! -f "$file" ]]; then
    printf '%s\n%s\n' "$heading" "$entry" > "$file"
    return
  fi

  if ! grep -Fxq "$heading" "$file"; then
    {
      [[ -s "$file" ]] && printf '\n'
      printf '%s\n%s\n' "$heading" "$entry"
    } >> "$file"
    return
  fi

  local tmp
  tmp="${file}.tmp.$$"
  awk -v heading="$heading" -v entry="$entry" '
    $0 == heading { print; in_section = 1; next }
    in_section && $0 ~ /^## / { print entry; in_section = 0 }
    { print }
    END { if (in_section) print entry }
  ' "$file" > "$tmp"
  mv "$tmp" "$file"
}

cmd_add() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    read -r -p "New notebook name: " name
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ -f "$file" ]]; then
    echo "Notebook already exists: $name" >&2
    return 1
  fi
  printf '# %s\n' "$name" > "$file"
  echo "Created notebook: $name"
}

cmd_remove() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  read -r -p "Remove '$name'? [y/N] " confirm
  case "$confirm" in
    y|Y|yes|YES)
      rm "$file"
      echo "Removed notebook: $name"
      ;;
    *)
      echo "Cancelled."
      ;;
  esac
}

cmd_append() {
  ensure_dir
  local name="${1:-}"
  local force_select="${2:-}"
  if [[ -z "$name" || -n "$force_select" ]]; then
    if [[ -z "$force_select" ]]; then
      local default
      default=$(get_default_notebook)
      if [[ -n "$default" ]]; then
        name="$default"
      fi
    fi
    if [[ -z "$name" ]]; then
      name=$(select_notebook) || return 1
    fi
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi

  local clip
  clip=$(get_clipboard)
  if [[ -z "${clip//[$' \t\r\n']/}" ]]; then
    echo "Clipboard is empty." >&2
    return 1
  fi

  local entry
  entry=$(format_entry "$clip")
  append_to_notebook "$file" "$entry"
  echo "Appended to $name"
}

cmd_search() {
  ensure_dir
  local query="${1:-}"
  if [[ -z "$query" ]]; then
    read -r -p "Search query: " query
  fi
  if [[ -z "$query" ]]; then
    echo "Search query is required." >&2
    return 1
  fi

  if [[ -z "$(list_notebooks)" ]]; then
    echo "No notebooks found. Use 'tkn add' to create one." >&2
    return 1
  fi

  local pattern="$query"
  local search_cmd=(awk -v pat="$pattern" '
    FNR == 1 { date = "" }
    /^## / { date = substr($0, 4) }
    $0 ~ pat {
      file = FILENAME
      sub(/^.*\//, "", file)
      sub(/\.md$/, "", file)
      line = FNR
      content = $0
      if (date == "") {
        date = "UNKNOWN"
      }
      printf "%s:%s | %s | %s\n", file, line, date, content
    }
  ' "$NOTEBOOK_DIR"/*.md)

  if command -v fzf >/dev/null 2>&1; then
    "${search_cmd[@]}" | fzf --prompt="Results> " --height=60% --border || true
  else
    "${search_cmd[@]}" || true
  fi
}

cmd_open() {
  ensure_dir
  local name="${1:-}"
  if command -v fzf >/dev/null 2>&1; then
    local wrap_mode
    wrap_mode=$(get_preview_wrap)
    local fzf_cmd=(
      fzf
      --prompt="Notebook> "
      --height=70%
      --border
      --preview "cat \"$NOTEBOOK_DIR\"/{}.md"
      --preview-window=right:60%:${wrap_mode}
      --bind "ctrl-j:preview-down,ctrl-k:preview-up,pgdn:preview-page-down,pgup:preview-page-up,ctrl-f:preview-page-down,ctrl-b:preview-page-up,ctrl-l:toggle-preview"
      --header "Enter/Esc to exit | Ctrl-J/K scroll | Ctrl-L toggle preview"
    )

    if [[ -n "$name" ]]; then
      validate_name "$name"
      local file
      file=$(notebook_path "$name")
      if [[ ! -f "$file" ]]; then
        echo "Notebook not found: $name" >&2
        return 1
      fi
      printf '%s\n' "$name" | "${fzf_cmd[@]}" || true
      return 0
    fi

    list_notebooks | "${fzf_cmd[@]}" || true
    return 0
  fi

  if [[ -n "$name" ]]; then
    validate_name "$name"
    local file
    file=$(notebook_path "$name")
    if [[ ! -f "$file" ]]; then
      echo "Notebook not found: $name" >&2
      return 1
    fi
    less "$file"
    return 0
  fi

  name=$(select_notebook) || return 1
  less "$(notebook_path "$name")"
}

cmd_default() {
  ensure_dir
  local name="${1:-}"
  if [[ "$name" == "--clear" || "$name" == "clear" ]]; then
    clear_default_notebook
    echo "Default notebook cleared."
    return 0
  fi
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  if is_reserved_name "$name"; then
    echo "Notebook name is reserved: $name" >&2
    return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi
  set_default_notebook "$name"
  echo "Default notebook set to: $name"
}

cmd_config() {
  local key="${1:-}"
  local value="${2:-}"
  case "$key" in
    dir)
      if [[ -z "$value" ]]; then
        echo "$NOTEBOOK_DIR"
        return 0
      fi
      mkdir -p "$CONFIG_DIR"
      printf '%s' "$value" > "$NOTEBOOK_DIR_FILE"
      NOTEBOOK_DIR="$value"
      mkdir -p "$NOTEBOOK_DIR"
      echo "Notebooks directory set to: $NOTEBOOK_DIR"
      ;;
    editor)
      if [[ -z "$value" ]]; then
        if resolve_editor >/dev/null 2>&1; then
          resolve_editor
        else
          echo "Editor is not set."
        fi
        return 0
      fi
      mkdir -p "$CONFIG_DIR"
      printf '%s' "$value" > "$EDITOR_FILE"
      echo "Editor set to: $value"
      ;;
    wrap)
      if [[ -z "$value" ]]; then
        get_preview_wrap
        return 0
      fi
      case "$value" in
        wrap|nowrap)
          set_preview_wrap "$value"
          echo "Preview wrap set to: $value"
          ;;
        *)
          echo "Value must be 'wrap' or 'nowrap'." >&2
          return 1
          ;;
      esac
      ;;
    reset)
      rm -f "$EDITOR_FILE" "$NOTEBOOK_DIR_FILE" "$GIT_REMOTE_FILE" "$WRAP_PREVIEW_FILE"
      NOTEBOOK_DIR="${TAKEN_DIR:-$NOTEBOOK_DIR_DEFAULT}"
      echo "Config reset (dir/editor/git/wrap)."
      ;;
    ""|help|-h|--help)
      echo "Usage: tkn config <dir|editor|wrap|reset> [value]" >&2
      return 1
      ;;
    *)
      echo "Unknown config key: $key" >&2
      return 1
      ;;
  esac
}

ensure_git_repo() {
  if [[ ! -d "$NOTEBOOK_DIR/.git" ]]; then
    git -C "$NOTEBOOK_DIR" init >/dev/null
  fi
}

cmd_sync() {
  ensure_dir
  local remote="${1:-}"
  if [[ -n "$remote" ]]; then
    set_git_remote "$remote"
    echo "Git remote set to: $remote"
    echo "Make sure git credentials are configured for this remote."
  else
    remote=$(get_git_remote)
  fi
  if [[ -z "$remote" ]]; then
    echo "No git remote configured. Run: tkn sync <remote-url>" >&2
    return 1
  fi

  if ! command -v git >/dev/null 2>&1; then
    echo "git is required for sync." >&2
    return 1
  fi

  ensure_git_repo

  if ! git -C "$NOTEBOOK_DIR" remote get-url origin >/dev/null 2>&1; then
    git -C "$NOTEBOOK_DIR" remote add origin "$remote"
  else
    git -C "$NOTEBOOK_DIR" remote set-url origin "$remote"
  fi

  local has_remote_refs=0
  if git ls-remote --exit-code --heads "$remote" >/dev/null 2>&1; then
    has_remote_refs=1
  fi

  if [[ "$has_remote_refs" -eq 1 ]]; then
    git -C "$NOTEBOOK_DIR" pull --rebase --autostash origin >/dev/null
  fi

  git -C "$NOTEBOOK_DIR" add -A
  if ! git -C "$NOTEBOOK_DIR" diff --cached --quiet; then
    git -C "$NOTEBOOK_DIR" commit -m "Update notebooks" >/dev/null
  fi

  if ! git -C "$NOTEBOOK_DIR" rev-parse --verify HEAD >/dev/null 2>&1; then
    echo "Nothing to sync." >&2
    return 0
  fi

  local branch
  branch=$(git -C "$NOTEBOOK_DIR" rev-parse --abbrev-ref HEAD)
  if [[ "$branch" == "HEAD" ]]; then
    branch="main"
    git -C "$NOTEBOOK_DIR" checkout -b "$branch" >/dev/null 2>&1 || true
  fi

  git -C "$NOTEBOOK_DIR" push -u origin "$branch" >/dev/null
  echo "Sync complete."
}

cmd_edit() {
  ensure_dir
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name=$(select_notebook) || return 1
  fi
  validate_name "$name"
  local file
  file=$(notebook_path "$name")
  if [[ ! -f "$file" ]]; then
    echo "Notebook not found: $name" >&2
    return 1
  fi

  local editor
  editor=$(get_editor)
  "$editor" "$file"
}

cmd_today() {
  local today
  today=$(date +"$DATE_FMT")
  print_date_matches "$today" "$today"
}

cmd_yesterday() {
  local today
  today=$(date +"$DATE_FMT")
  local yday
  yday=$(date_shift "$today" -1)
  print_date_matches "$yday" "$yday"
}

cmd_last() {
  local span="${1:-}"
  if [[ -z "$span" ]]; then
    echo "Usage: tkn last <week|month>" >&2
    return 1
  fi
  local today
  today=$(date +"$DATE_FMT")
  local start
  case "$span" in
    week)
      start=$(date_shift "$today" -6)
      ;;
    month)
      start=$(date_shift "$today" -29)
      ;;
    *)
      echo "Unknown range: $span" >&2
      return 1
      ;;
  esac
  print_date_matches "$start" "$today"
}

cmd_between() {
  local m1="${1:-}"
  local m2="${2:-}"
  local year="${3:-}"
  if [[ -z "$m1" || -z "$m2" ]]; then
    echo "Usage: tkn between <m1> <m2> [year]" >&2
    return 1
  fi
  if [[ -z "$year" ]]; then
    year=$(date +"%Y")
  fi
  local m1_num
  local m2_num
  m1_num=$(month_to_num "$m1") || { echo "Unknown month: $m1" >&2; return 1; }
  m2_num=$(month_to_num "$m2") || { echo "Unknown month: $m2" >&2; return 1; }
  if ((10#$m2_num < 10#$m1_num)); then
    echo "End month must be after start month." >&2
    return 1
  fi

  local start="${year}-${m1_num}-01"
  local end
  end=$(last_day_of_month "$year" "$m2_num")
  print_date_matches "$start" "$end"
}

cmd_on() {
  local d="${1:-}"
  if [[ -z "$d" ]]; then
    echo "Usage: tkn on <YYYY-MM-DD>" >&2
    return 1
  fi
  print_date_matches "$d" "$d"
}

main() {
  load_config
  ensure_dir
  local cmd="${1:-}"
  local next="${2:-}"
  case "$cmd" in
    "" )
      cmd_append
      ;;
    -s|--select)
      cmd_append "" "select"
      ;;
    -*)
      echo "Unknown option: $cmd" >&2
      usage >&2
      return 1
      ;;
    add)
      shift
      cmd_add "${1:-}"
      ;;
    remove|rm|delete)
      shift
      cmd_remove "${1:-}"
      ;;
    search|find)
      shift
      cmd_search "${1:-}"
      ;;
    open|view)
      shift
      cmd_open "${1:-}"
      ;;
    default)
      shift
      cmd_default "${1:-}"
      ;;
    config)
      shift
      cmd_config "${1:-}" "${2:-}"
      ;;
    sync)
      shift
      cmd_sync "${1:-}"
      ;;
    edit)
      shift
      cmd_edit "${1:-}"
      ;;
    today)
      cmd_today
      ;;
    yesterday)
      cmd_yesterday
      ;;
    last)
      shift
      cmd_last "${1:-}"
      ;;
    between)
      shift
      cmd_between "${1:-}" "${2:-}" "${3:-}"
      ;;
    on)
      shift
      cmd_on "${1:-}"
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      if is_reserved_name "$cmd"; then
        echo "Unknown command: $cmd" >&2
        usage >&2
        return 1
      fi
      cmd_append "$cmd"
      ;;
  esac
}

main "$@"
